#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import ast
import random
import re
import json
from ctypes import *

from fuzzer_module.Fuzzconfig import *


# The operation of Memory Shared.
# 1. Find the memory share id
# ipcs -lm
# ipcs -m
# ipcs -m | grep shmid
# 2. Delete memory share.
# ipcrm -m shmid

# Change the number of SHMMAX (8GB)
# echo "8589934592" > /proc/sys/kernel/shmmax  OR  sysctl -w kernel.shmmax=2147483648
# echo "kernel.shmmax=8589934592" >> /etc/sysctl.conf

class Analyzer:
    def __init__(self):
        self.global_shm_key = USE_INITNUM
        self.addr = None
        self.sendaddr = None
        try:
            self.rt = CDLL('librt.so')
        except:
            self.rt = CDLL('librt.so.1')
        self.shmget = self.rt.shmget
        self.shmget.argtypes = [c_int, c_size_t, c_int]
        self.shmget.restype = c_int

        self.shmat = self.rt.shmat
        self.shmat.argtypes = [c_int, POINTER(c_void_p), c_int]
        self.shmat.restype = c_void_p


    # Combination Functions
    # getAddr()
    # getInterlen()
    # getRpt()
    # traceAyalysis()

    def sendCmpid(self, cmpid):
        """
        Send cmpid to save the cmpid information.
        @param cmpid:
        @return:
        """
        if self.sendaddr is None:
            shmid = self.shmget(ANA_SEND_KEY, ANA_SEND_SIZE, 0o1000 | 0o666)  # IPC_CREAT | Permission
            while shmid < 0:
                randkey = random.randint(100000, 999999)
                shmid = self.shmget(randkey, ANA_SEND_SIZE, 0o1000 | 0o666)  # IPC_CREAT | Permission
                with open(ANA_SEND_FILE, "w") as f:
                    f.write(str(randkey))
            self.sendaddr = self.shmat(shmid, None, 0)

        cmpid = str(cmpid) + "\0"
        memmove(self.sendaddr, cmpid.encode(), len(cmpid))

    def getAddr(self, out_info: str):
        """
        Get the memory share address.
        @param out_info:
        @return:
        """
        try:
            re_str = SHMID_FLAG + "(.*?)" + END_EACH_FLAG
            shm_key = int(re.search(re_str, str(out_info)).group(1))
            # print(shm_key)
        except Exception as e:
            # raise Exception("Error shm_key {}".format(e))
            shm_key = self.global_shm_key

        LOG(LOG_DEBUG, LOG_FUNCINFO(), shm_key, self.global_shm_key)
        if shm_key != self.global_shm_key:
            self.global_shm_key = shm_key

            shmid = self.shmget(shm_key, ANA_SHM_SIZE, 0o1000 | 0o666)  # 2*1024*1024*1024 2GB
            if shmid < 0:
                raise Exception("Error System not shared.")

            self.addr = self.shmat(shmid, None, 0)

        return self.addr

    def getInterlen(self, addr):
        """
        Get the length of rpt.
        @param addr:
        @return:
        """
        # Get the length of cmpcovshm contents.
        interlen_str = string_at(addr, ANA_INTERLEN_SIZE).decode("utf-8")
        re_str = INTERLEN_FLAG + "(.*?)" + END_EACH_FLAG
        interlen = int(re.search(re_str, interlen_str).group(1))
        return interlen

    def getRpt(self, interlen, addr):
        """
        Get the list of cmp information.
        @param interlen:
        @param addr:
        @return:
        """
        # Read content in pieces
        pieces = interlen // ANA_SHM_INTERVAL
        over = interlen % ANA_SHM_INTERVAL

        cmpcovshm_str = "["
        if pieces > 0:
            cmpcovshm_str += string_at(addr + ANA_INTERLEN_SIZE, ANA_SHM_INTERVAL - ANA_INTERLEN_SIZE).decode("utf-8",
                                                                                                              "ignore")
            for each in range(1, pieces):
                cmpcovshm_str += string_at(addr + ANA_SHM_INTERVAL * each, ANA_SHM_INTERVAL).decode("utf-8", "ignore")
            # fixme .decode("utf-8", "ignore")
            cmpcovshm_str += string_at(addr + ANA_SHM_INTERVAL * pieces, over).decode("utf-8", "ignore")
        else:
            cmpcovshm_str += string_at(addr + ANA_INTERLEN_SIZE, over - ANA_INTERLEN_SIZE).decode("utf-8", "ignore")
        cmpcovshm_str += "]"

        # Make the fuzz loop block.
        # self.rt.shmctl(shmid, 0, 0)

        # Content to json
        LOG(LOG_DEBUG, LOG_FUNCINFO(), cmpcovshm_str)
        cmpcov_list = ast.literal_eval(cmpcovshm_str)
        del cmpcovshm_str
        return cmpcov_list

    def traceAyalysis(self, cmpcov_list, freezeid_rpt, type_info):
        """
        # Analysis of trace reports generated by documents. memoryTrace
        # Iterate through the trace list to generates the corresponding cmpid dictionary.
        @param cmpcov_list:
        @param freezeid_rpt:
        @param type_info:
        @return:
        """
        cmp_dict = {}  # According cmp instruction to genetator dict.
        for each_i in cmpcov_list:
            if each_i[IDX_CMPTYPE] in type_info and each_i[IDX_CMPID] not in freezeid_rpt:
                cmpid = each_i[IDX_CMPID]
                if cmpid not in cmp_dict:
                    cmp_dict[cmpid] = [each_i[0:IDX_CMPID] + each_i[IDX_CMPID + 1:]]
                else:
                    cmp_dict[cmpid].append(each_i[0:IDX_CMPID] + each_i[IDX_CMPID + 1:])
        return cmp_dict

    def traceGuardAnalysis(self, guardcov_list):
        """
        Perform a trace of the compare instruction execution path if necessary.
        """
        # Iterate through the trace report to get the corresponding information
        guard_set = set()
        guard_total = USE_INITNUM
        for trace_i in guardcov_list:
            if trace_i[IDX_CMPTYPE] == EACH_PC_GUARD:
                guard_set.add(trace_i[1])
            elif trace_i[IDX_CMPTYPE] == INIT_PC_GUARD:
                guard_total = trace_i[3]
        return guard_set, guard_total

    '''
    Tracking Comparison Module.
    '''
    def compareRptToLoc(self, b4cmp_dict, b4cmpset, cmp_dict):
        cmpset = set(cmp_dict)
        interset = b4cmpset & cmpset  # Intersection set
        symdiffset = b4cmpset ^ cmpset  # Symmetric Difference set
        diffcmp_set = set()
        LOG(LOG_DEBUG, LOG_FUNCINFO(), interset, symdiffset)

        # Intersection set
        # compare whether the parameters of the same constraint are different.
        # Faster comparisons can be achieved by using arrays instead of structures.
        for key_i in interset:
            if b4cmp_dict[key_i] != cmp_dict[key_i]:
                diffcmp_set.add(key_i)

        # Symmetric Difference set
        for key_i in symdiffset:
            diffcmp_set.add(key_i)

        return diffcmp_set



if __name__ == "__main__":
    ana = Analyzer()
    # ana.sendCmpid("abcde"+"\0")
    # ana.sendCmpid("None\0")
    ana.sendCmpid("Guard\0")
    # ana.sendCmpid("o0x7ffff7e770a8\0")
    # while True:
    #     addr = ana.getAddr("D124816Z\n")
    #     interlen = ana.getInterlen(addr)
    #     print(interlen)
    #     cmpcovshm_list = ana.getRpt(interlen, addr)
    addr = ana.getAddr("D124816Z\n")
    interlen = ana.getInterlen(addr)
    cmpcovshm_list = ana.getRpt(interlen, addr)
    with open("../Programs/TrackCrash/crashinfo/info", "w") as f:
        f.write(str(cmpcovshm_list))
    print(cmpcovshm_list)
    # print(cmpcovshm_list)
